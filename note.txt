Problem zapisu danych z modelu obiektowego do relacyjnej bazy danych.
w obkietkowoœci to s¹ obiekty po³¹czone ze sob¹ referencjami
w bazach relacyjnych - tabele.
Aby umo¿liwiæ po³¹czenie miêdzy obiektami a baz¹ danych wykorzystujemy interfejs JDBC - java database connectivity.
Jest to jednolite API korzustaj¹ce ze sterowników (biblioteki dla okreœlonych baz danych (odpowiedni jar)). 
Po JDPC powsta³o kilka innych rozwi¹zañ: JDPC Template - wzorzec, który umo¿liwa wykonywaæ zapytania w ³atwiejszy sposób. Unikamy problemów z ³apaniem wyj¹tków. Mamy do dyspozycji mappery,
 czyli klasy pozwal¹ce mapowaæ (data mappery). Jest wiele wiele wiêcej takich narzêdzi, nazwanych ogólnie ORM - Object Relational Mapping.

JPA - dokument, który opisuje w jaki sposób programista powinien pisaæ programy z wykorzystaniem JPA oraz jak powinna przebiegaæ implementacja (np. Hibernate jest implementacj¹ JPA).

Podstawowa konfiguracja nie wykorzustyj¹ca bootstrapa przebiega nastêpuj¹co:
	1. Mo¿na pobraæ ca³¹ paczkê jar hibernate-jpa-2.0-api
	2. Stworzenie projektu maven i dodanie dependencies: entitymenager, validator, search i core(?).
	3. Dodanie dependencies hibernate-jpa-2.0-api
Nastêpnie tworzymy w resoucres folder META-INF a w nim plik persistence.xml

Kolejn¹ bilbiotek¹ jest biblioteka ³¹cz¹ca siê z baz¹ czyli jdbc danej bazy danych.

Aby utworzyæ po³¹æzenie z baz¹ nale¿y wykorzystaæ EntityManagerFactor objekt, a nastêpnie stworzyæ na jego podstawie objekt EntityManager.

Korzystaj¹c z obiektu entityManager mo¿emy wykonywaæ transakcjê na bazie danych umo¿liwiaj¹ce operacje zapisu. A nastêpnie wykorzystuj¹c funkcjê presist zapisujemy wybrany obiekt w bazie danych.
 entityManager.getTransaction().begin();
 entityManager.persist(foo);
 entityManager.getTransaction().commit();

Pamiêtaæ o tym, aby w klasie na podstawie której chcemy utworzyæ tabele nale¿y dodaæ adnotacjê @Entity.

Przydatne adnotacje:
	1. @GeneratedValue(strategy = GenerationType.AUTO) - auto generowanie ID;
	2. @Column(name = "bla", nullable = false, length = 10) - d³ugoœæ i not null
	3. @Column(precision = 10, scale = 2) - dla BigDecimali iloœæ liczb dziesiêtnych i po przeicnku
	4. @Transient - dodana przy polu pomija go i nie dodaje jako kolumna w tabeli bazy danych.


Data i czas:
Wszystkie klasy java.sql.* s¹ wraperem na klasê java.util.Date
U¿ywaj¹c adnotacji @Temporal(TemporalType.DATE/TIME/TIMESTAMP) mo¿emy ustaliæ dany typ kolumny w bazie danuych.

Jedna klasa - dwie tabele:
Aby utworzyæ dwie tabele na podstawie jednej klasy dopisujemy adnotacjê @SecondTable(name = "nazwa_tabeli", pkJoinColumns = @PrimaryKeyJoinColumn(name = "nazwa_id_dla_primary_table"));
Nastêpnie do pól, które chcemy aby by³y w drugiej tabeli dodajemy adnotacjê @Table(name = "nazwa_tabeli_z_adnotacji_secondtable");

Klasa osadzona:
Klasa osadzona jest osobn¹ klas¹ z poziomu kodu, natomiast zawiera adnotacjê @Embeddable. Dziêki temu tworz¹c pole tej klasy w innej klasie oraz dodaj¹c adnotacjê @Embbeded
zostanie utworzona jedna tabela zmiast dwóch, ³¹cz¹ca pola z obu klas.

One-to-one:
Relacje jeden do jednego pomiêdzy dwoma klasami/tabelami tworzymy z u¿yciem adnotacji @OneToOne w jednej z klas przy polu, kórym jest obiuekt drugiej klasy.

Pobieranie i modyfikacja obiektu:
¯eby pobraæ obiekt wykorzystujemy metodê "find" z entity managera, która zwraca nam obiekt o typie podanym jako pierwszy parametr metody.
Mo¿emy nastêpnie zmodyfikowaæ taki obiekt wykorzystuj¹c settery i nie musimy go ponownie zapisywaæ do bazy metod¹ persist, w momencie commitowania tranzakcji obiekt ten
jest automatycznie aktualizowany.

Triggery:
Stworzony trigger w PostgreSQL, który po dodaniu pracownika do bazy danych automatycnzie wylicza i ustawia wartoœæ dla poola "tax".

Usuwanie obiektów z DB:
Wykorzystujemy metodê entity managera - remove(), któa przyjmuje referencje do usuwanego obiektu. Wczeœniej najlepiej znaleŸæ sobie odpowiedni obiekt metod¹ find, a nastêpnie go usun¹æ.
Pamiêtaæ o tym aby usuwanie obiektu przeprowadziæ w osobnej trasakcji!

JPQL:
Do wykonania zapytania na bazie danych w tym jêzyku nale¿y skorzystaæ z metody entity managera - query. Aczkolwiek ten sposób nie jest bezpieczny patrz¹c od strony programistycznej.
Przekazywanie parametrów zadanych w JPQL wygl¹da nastêpuj¹co, w query w miejscu w którym chcemy zadaæ jak¹œ wartoœæ poprzedzamy nazwê zmiennej dwukropkiem np. "where e.salary > :minSalary".
Nastêpnie parametr taki inicjalizujemy za pomoc¹ metody setParametr("minSalary", 3000.0);
Inn¹ metod¹ podstawiania zmienny jest indeksowanie, wygl¹da ona nasepuj¹co: "where e.salary > ?1", a nastêpnie w petodzie setParametr ustawiamy j¹w ten spobób setParametr(1, 2000.0);
Ostania metoda to przekazanie ca³ej listy zmiennych, które ma spe³niaæ zapytanie: "where e.lastName in :names" - znalezienie wszystkich pracowników ktrórych nazwiska znajduj¹ si w liœcie "names".
Tworzymy tak¹ listê, a nastêpnie przypisujemy j¹ w metodzie setParametr("names", names);

Adtrybut name w @Entity ustawia domyœln¹ nazwê dla tabeli w bazie danych. Co wiêcej ten atrybut wykorzystuje siê w zapytaniach JPQL.
W przypadku nadawania name w adotacji @Table ma ona wiêkszy priortytet ni¿ name w @Entity. @Table odnoœi sie jedynie do bazy danych,
natomiast @Entity odnoœi siê do kodu i zapytañ JPQL.
W zapytaniach JPQL istotna jest WIELKOŒÆ ZNAKÓW.
Funckje w JPQL dzia³aj¹ tak samo jak w SQL. Przyk³ady takie jak av(), sum(), count() itd...



RELACJE W JPA:
@OneToOne -> Unidirectional i Bidirectional. Jedno i dwu kieurnkowa.
@OneToMany -> Unidirectional i Bidirectional. Jedno i dwu kieurnkowa.
@ManyToMany -> Bidirectional: Dwukierunkowa

@OneToOne:
Przy relacji dwukierunkowej nale¿y dodaæ w obu encjach pola drugiego obiektu wraz z adnotacj¹ @OneToOne. W tej mniej znacz¹cej, a bardziej w tej, której pola nie chcemy w DB
dodajemy mapped by = "nazwa pola z drugiej encji.
Je¿eli nie dalibyœmy mapped by to tak naprawdê stworzylibyœmy dwie jednokierunkowe relacje, które by³yby ze sob¹ tylko pozornie powi¹zane.
@OneToMany:
Przy relacji jednokierunowej nale¿y stworzyæ dwie encje, a nastêpnie w jednej z nich tworzymy listê obiektów z drugiej encji i dodajemy adnotacjê @OneToMany, mo¿emy równie¿ dodaæ
adnotacjê @JoinColumn i stworzyæ kolumne o zadanej nazwie w drugim obiekcie bazodanowym.
Przy relacji dwukieunkowej zasada podobna do dwukierunkowej w @onetoone, nalezy pamiêtaæ o mapped by po stronie encji, w której jest @OneToMany (jeden).
W tym wypadku @Joincolumn dajemy w encji, której jest wiele (@ManyToOne)

!!!WA¯NE!!! - w momencie gdy tworzymy konstruktor sprametryzowany dla encji wa¿nym jest aby stworzyæ równie¿ konstrukotor domyœlny na potrzeby JPA. W innym wypadku zapis i odczyt z bazy nie zadzia³a.

@ManyToMany:
Relacja ta mo¿e byæ jedynie dwukierunkowa. Tworzymy j¹ dodaj¹c adnotacjê @ManyToMany w ka¿dej z encji przy polu drugiej encji.
W jednej z nich musimy dodaæ "mapped by"tak jak w powy¿szych przyk³adach.
JPA automatycznie utworzy w naszej bazie danych dodatkow¹ tabelê przedstawiaj¹c¹ relacjê obu encji.
Domyœlnie nazwa ta jest to nazwa jednej tabeli + "_" + nazwa drugiej tabeli.
Mozemy zmieniæ nazwê tabeli ³¹cz¹cej wykorzystjuj¹c adnotacjê @JoinTable w jednej z encji pod adnotacj¹ @ManyToMany.
Wygl¹da ona nastêpuj¹co
 @ManyToMany
    @JoinTable(
            name = "pracownicy_w_projektach",
            joinColumns = {@JoinColumn(name = "id_projektu")},
            inverseJoinColumns = {@JoinColumn(name = "id_pracownika")}
    )

AUTOGENEROWANE WARTOŒCI:
@GeneratedValue:
1. strategy = AUTO - hibernate automtycznie wybiera najodpowiedniejsz¹ z trzech dostêpnych strategii.
2. strategy = IDENTITY - automatyczne dodawanie kluczy przez bazê danych. 
3. strategy = SEQUENCE - w bazie danych zostanie stworzona sekwencja.
4. strategy = TABLE - zostanie stworzona tabela w bazie danych (domyœlnie hibernate_sequences), która jest odpowiedzialna
za przydzielanie kolejnych identyfikatorów podczas dodawania nowych pracowników.
Hibernate rezerwuje sobie pulê idków i w momencie gdy wie ¿e bêdzie przydziela³ identyfikatory (w momencie tworzenia obiektu)
to nie zwiêksza za ka¿dym razem wartoœæ w tabeli hibernate_sequence tylko zwiêksza id obiektu o liczbê zarezerwowanych idków
a liczbê w tabeli hibernate_sequence o 1. Chodzi o wydajnoœæ, hibernate nie musi za ka¿dym razem gdy dodaje obiekt odwo³ywaæ siê
do tabeli hibernate_sequence - ma ju¿ zarezerwowane idki.
Mo¿emy konfigurowaæ domyœln¹ tabelê hibernate_sequence i jej warotœci w nastêpuj¹cy sposób:

@TableGenerator(name = "mojGenerator",
        table = "tabela_z_identyfikatorami",
            pkColumnName = "nazwa_sekwencji",
            valueColumnName = "wartosc_identyfikatora",
            pkColumnValue = "id_pracownika",
            initialValue = 10,
            allocationSize = 15
    )

dodatkowo musimy w @GeneratedValue wskazaæ na generator, który skonfigurowaliœy w powy¿szej adnotacji:
@GeneratedValue(strategy = GenerationType.TABLE, generator = "mojGenerator")

DZIEDZICZENIE W JPA:
Do dziedziczenia wykorzystujemy nastêpuj¹ce adnotacje:
@Inheritance(strategy = InheritanceType.SINGLE_TABLE) oraz dodatkowo zmiana nazw kolumny DTYPE oraz jej wartoœci za pomoc¹
adnotacji @DiscriminatorColumn w klasie po której dziedzicz¹ oraz @DiscriminatorValue w klasach dziedzicz¹cych.

1. Single Table (domyœlny) - wystarczy zwyk³y extend klasy. Powstaje w db jedna tabela posiadaj¹ca wszystkie kolumny, z klasy 
po której siê dziedziczy oraz klas dziedzicz¹cych + pole DTYPE, które definiuje do którego obiektu, który dziedziczy
odnosi siê dany wiersz.

2. Joined - poswstaje tabla nadrzêdna, w którym jest id + tylko atrybuty tylko z klasy g³ównej. W klasach (tabelach) dziedizcz¹cych
s¹ jedynie pola tych klas + idki wi¹¿¹ce te tabele z tabel¹ nadrzêdn¹. Identyfikatory z tabeli nadrzêdnej odpowiadj¹ takim samym
identyfikatorom obiektów w tabelach podrzêdnych.
U¿ywamy tutaj adnotacjê: @Inheritance(strategy = InheritanceType.JOINED)

3. Table Per Class - Tutaj dla ka¿dej encji dziedzicz¹cej po encji nadrzêdnej powstaje osobna tablea w bazie danych.
Tabela taka posiada pola z klasy po której dziedziczy + w³asne pola. Oprócz tego powstaje tabela odpowiedzialna za nadawanie
identyfikatorów dla tych tabel. Potrzebna poniewa¿ definiuje po³¹czenie miêdzy tymi tabelami, wiêc ka¿dy obiekt musi mieæ inny id,
skoro dziedzicz¹ po tej samej encji. (Teraz ju¿ chyba hibernate sam wybiera, ale...) Wa¿nym jest ¿eby idki nie by³y generowane
ze strategi¹ AUTO, a ze strategi¹ TABLE. Sekwencja idków miêdzy tymi tabelami jest wspó³dzielona.
Tutaj u¿ywamy adnotacjê:  @Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)

CRITERIA API:
Dodana metoda do JPA, która pozwala pobieraæ dane z bazy danych. Ró¿ni siê to od JPQL tym, ¿e nie tworzymy stringów podobnych do jêzyka SQL tylko
zapytania tworzymy w czysto programistyczny sposób.
Za poomc¹ EntityManagera tworzymy obiekt CriteriaBuilder, który ma nastêpuj¹ce metody:
	createQuery - zwraca znany obiekt lub niewiadomo co zwróci
	createTuple - zwraca kilka obiektów (np. imie (string) i pensje (double))
	createCriteriaDelete - usuwanie dany z bazy
	createCriteriaUpdate - aktualizacja danych w bazie

Nastêpnie musimy z u¿yciem criteriaQuery wywo³aæ metodê "from" ¿eby zaznaczyæ sk¹d wybierane dane.
Nasepnie wywo³anie metody "select" gdzie okreœlamy co bêdizem ywybieraæ
Ostatnia klauzula to "where" gdzie z u¿yciem buildera tworzymy listê wyra¿eñ, które musz¹ byæ spe³nione.
Nastepnie w entityManagerze wywo³ujemy createQuery gdize jako parametr podajemy nasze criteriaQuery.
