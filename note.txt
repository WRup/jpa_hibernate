Problem zapisu danych z modelu obiektowego do relacyjnej bazy danych.
w obkietkowoœci to s¹ obiekty po³¹czone ze sob¹ referencjami
w bazach relacyjnych - tabele.
Aby umo¿liwiæ po³¹czenie miêdzy obiektami a baz¹ danych wykorzystujemy interfejs JDBC - java database connectivity.
Jest to jednolite API korzustaj¹ce ze sterowników (biblioteki dla okreœlonych baz danych (odpowiedni jar)). 
Po JDPC powsta³o kilka innych rozwi¹zañ: JDPC Template - wzorzec, który umo¿liwa wykonywaæ zapytania w ³atwiejszy sposób. Unikamy problemów z ³apaniem wyj¹tków. Mamy do dyspozycji mappery,
 czyli klasy pozwal¹ce mapowaæ (data mappery). Jest wiele wiele wiêcej takich narzêdzi, nazwanych ogólnie ORM - Object Relational Mapping.

JPA - dokument, który opisuje w jaki sposób programista powinien pisaæ programy z wykorzystaniem JPA oraz jak powinna przebiegaæ implementacja (np. Hibernate jest implementacj¹ JPA).

Podstawowa konfiguracja nie wykorzustyj¹ca bootstrapa przebiega nastêpuj¹co:
	1. Mo¿na pobraæ ca³¹ paczkê jar hibernate-jpa-2.0-api
	2. Stworzenie projektu maven i dodanie dependencies: entitymenager, validator, search i core(?).
	3. Dodanie dependencies hibernate-jpa-2.0-api
Nastêpnie tworzymy w resoucres folder META-INF a w nim plik persistence.xml

Kolejn¹ bilbiotek¹ jest biblioteka ³¹cz¹ca siê z baz¹ czyli jdbc danej bazy danych.

Aby utworzyæ po³¹æzenie z baz¹ nale¿y wykorzystaæ EntityManagerFactor objekt, a nastêpnie stworzyæ na jego podstawie objekt EntityManager.

Korzystaj¹c z obiektu entityManager mo¿emy wykonywaæ transakcjê na bazie danych umo¿liwiaj¹ce operacje zapisu. A nastêpnie wykorzystuj¹c funkcjê presist zapisujemy wybrany obiekt w bazie danych.
 entityManager.getTransaction().begin();
 entityManager.persist(foo);
 entityManager.getTransaction().commit();

Pamiêtaæ o tym, aby w klasie na podstawie której chcemy utworzyæ tabele nale¿y dodaæ adnotacjê @Entity.

Przydatne adnotacje:
	1. @GeneratedValue(strategy = GenerationType.AUTO) - auto generowanie ID;
	2. @Column(name = "bla", nullable = false, length = 10) - d³ugoœæ i not null
	3. @Column(precision = 10, scale = 2) - dla BigDecimali iloœæ liczb dziesiêtnych i po przeicnku
	4. @Transient - dodana przy polu pomija go i nie dodaje jako kolumna w tabeli bazy danych.


Data i czas:
Wszystkie klasy java.sql.* s¹ wraperem na klasê java.util.Date
U¿ywaj¹c adnotacji @Temporal(TemporalType.DATE/TIME/TIMESTAMP) mo¿emy ustaliæ dany typ kolumny w bazie danuych.

Jedna klasa - dwie tabele:
Aby utworzyæ dwie tabele na podstawie jednej klasy dopisujemy adnotacjê @SecondTable(name = "nazwa_tabeli", pkJoinColumns = @PrimaryKeyJoinColumn(name = "nazwa_id_dla_primary_table"));
Nastêpnie do pól, które chcemy aby by³y w drugiej tabeli dodajemy adnotacjê @Table(name = "nazwa_tabeli_z_adnotacji_secondtable");