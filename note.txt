Problem zapisu danych z modelu obiektowego do relacyjnej bazy danych.
w obkietkowoœci to s¹ obiekty po³¹czone ze sob¹ referencjami
w bazach relacyjnych - tabele.
Aby umo¿liwiæ po³¹czenie miêdzy obiektami a baz¹ danych wykorzystujemy interfejs JDBC - java database connectivity.
Jest to jednolite API korzustaj¹ce ze sterowników (biblioteki dla okreœlonych baz danych (odpowiedni jar)). 
Po JDPC powsta³o kilka innych rozwi¹zañ: JDPC Template - wzorzec, który umo¿liwa wykonywaæ zapytania w ³atwiejszy sposób. Unikamy problemów z ³apaniem wyj¹tków. Mamy do dyspozycji mappery,
 czyli klasy pozwal¹ce mapowaæ (data mappery). Jest wiele wiele wiêcej takich narzêdzi, nazwanych ogólnie ORM - Object Relational Mapping.

JPA - dokument, który opisuje w jaki sposób programista powinien pisaæ programy z wykorzystaniem JPA oraz jak powinna przebiegaæ implementacja (np. Hibernate jest implementacj¹ JPA).

Podstawowa konfiguracja nie wykorzustyj¹ca bootstrapa przebiega nastêpuj¹co:
	1. Mo¿na pobraæ ca³¹ paczkê jar hibernate-jpa-2.0-api
	2. Stworzenie projektu maven i dodanie dependencies: entitymenager, validator, search i core(?).
	3. Dodanie dependencies hibernate-jpa-2.0-api
Nastêpnie tworzymy w resoucres folder META-INF a w nim plik persistence.xml

Kolejn¹ bilbiotek¹ jest biblioteka ³¹cz¹ca siê z baz¹ czyli jdbc danej bazy danych.

Aby utworzyæ po³¹æzenie z baz¹ nale¿y wykorzystaæ EntityManagerFactor objekt, a nastêpnie stworzyæ na jego podstawie objekt EntityManager.

Korzystaj¹c z obiektu entityManager mo¿emy wykonywaæ transakcjê na bazie danych umo¿liwiaj¹ce operacje zapisu. A nastêpnie wykorzystuj¹c funkcjê presist zapisujemy wybrany obiekt w bazie danych.
 entityManager.getTransaction().begin();
 entityManager.persist(foo);
 entityManager.getTransaction().commit();

Pamiêtaæ o tym, aby w klasie na podstawie której chcemy utworzyæ tabele nale¿y dodaæ adnotacjê @Entity.

Przydatne adnotacje:
	1. @GeneratedValue(strategy = GenerationType.AUTO) - auto generowanie ID;
	2. @Column(name = "bla", nullable = false, length = 10) - d³ugoœæ i not null
	3. @Column(precision = 10, scale = 2) - dla BigDecimali iloœæ liczb dziesiêtnych i po przeicnku
	4. @Transient - dodana przy polu pomija go i nie dodaje jako kolumna w tabeli bazy danych.


Data i czas:
Wszystkie klasy java.sql.* s¹ wraperem na klasê java.util.Date
U¿ywaj¹c adnotacji @Temporal(TemporalType.DATE/TIME/TIMESTAMP) mo¿emy ustaliæ dany typ kolumny w bazie danuych.

Jedna klasa - dwie tabele:
Aby utworzyæ dwie tabele na podstawie jednej klasy dopisujemy adnotacjê @SecondTable(name = "nazwa_tabeli", pkJoinColumns = @PrimaryKeyJoinColumn(name = "nazwa_id_dla_primary_table"));
Nastêpnie do pól, które chcemy aby by³y w drugiej tabeli dodajemy adnotacjê @Table(name = "nazwa_tabeli_z_adnotacji_secondtable");

Klasa osadzona:
Klasa osadzona jest osobn¹ klas¹ z poziomu kodu, natomiast zawiera adnotacjê @Embeddable. Dziêki temu tworz¹c pole tej klasy w innej klasie oraz dodaj¹c adnotacjê @Embbeded
zostanie utworzona jedna tabela zmiast dwóch, ³¹cz¹ca pola z obu klas.

One-to-one:
Relacje jeden do jednego pomiêdzy dwoma klasami/tabelami tworzymy z u¿yciem adnotacji @OneToOne w jednej z klas przy polu, kórym jest obiuekt drugiej klasy.

Pobieranie i modyfikacja obiektu:
¯eby pobraæ obiekt wykorzystujemy metodê "find" z entity managera, która zwraca nam obiekt o typie podanym jako pierwszy parametr metody.
Mo¿emy nastêpnie zmodyfikowaæ taki obiekt wykorzystuj¹c settery i nie musimy go ponownie zapisywaæ do bazy metod¹ persist, w momencie commitowania tranzakcji obiekt ten
jest automatycznie aktualizowany.

Triggery:
Stworzony trigger w PostgreSQL, który po dodaniu pracownika do bazy danych automatycnzie wylicza i ustawia wartoœæ dla poola "tax".

Usuwanie obiektów z DB:
Wykorzystujemy metodê entity managera - remove(), któa przyjmuje referencje do usuwanego obiektu. Wczeœniej najlepiej znaleŸæ sobie odpowiedni obiekt metod¹ find, a nastêpnie go usun¹æ.
Pamiêtaæ o tym aby usuwanie obiektu przeprowadziæ w osobnej trasakcji!

JPQL:
Do wykonania zapytania na bazie danych w tym jêzyku nale¿y skorzystaæ z metody entity managera - query. Aczkolwiek ten sposób nie jest bezpieczny patrz¹c od strony programistycznej.
Przekazywanie parametrów zadanych w JPQL wygl¹da nastêpuj¹co, w query w miejscu w którym chcemy zadaæ jak¹œ wartoœæ poprzedzamy nazwê zmiennej dwukropkiem np. "where e.salary > :minSalary".
Nastêpnie parametr taki inicjalizujemy za pomoc¹ metody setParametr("minSalary", 3000.0);
Inn¹ metod¹ podstawiania zmienny jest indeksowanie, wygl¹da ona nasepuj¹co: "where e.salary > ?1", a nastêpnie w petodzie setParametr ustawiamy j¹w ten spobób setParametr(1, 2000.0);
Ostania metoda to przekazanie ca³ej listy zmiennych, które ma spe³niaæ zapytanie: "where e.lastName in :names" - znalezienie wszystkich pracowników ktrórych nazwiska znajduj¹ si w liœcie "names".
Tworzymy tak¹ listê, a nastêpnie przypisujemy j¹ w metodzie setParametr("names", names);

Adtrybut name w @Entity ustawia domyœln¹ nazwê dla tabeli w bazie danych. Co wiêcej ten atrybut wykorzystuje siê w zapytaniach JPQL.
W przypadku nadawania name w adotacji @Table ma ona wiêkszy priortytet ni¿ name w @Entity. @Table odnoœi sie jedynie do bazy danych,
natomiast @Entity odnoœi siê do kodu i zapytañ JPQL.
W zapytaniach JPQL istotna jest WIELKOŒÆ ZNAKÓW.
Funckje w JPQL dzia³aj¹ tak samo jak w SQL. Przyk³ady takie jak av(), sum(), count() itd...



RELACJE W JPA:
@OneToOne -> Unidirectional i Bidirectional. Jedno i dwu kieurnkowa.
@OneToMany -> Unidirectional i Bidirectional. Jedno i dwu kieurnkowa.
@ManyToMany -> Bidirectional: Dwukierunkowa

@OneToOne:
Przy relacji dwukierunkowej nale¿y dodaæ w obu encjach pola drugiego obiektu wraz z adnotacj¹ @OneToOne. W tej mniej znacz¹cej, a bardziej w tej, której pola nie chcemy w DB
dodajemy mapped by = "nazwa pola z drugiej encji.
Je¿eli nie dalibyœmy mapped by to tak naprawdê stworzylibyœmy dwie jednokierunkowe relacje, które by³yby ze sob¹ tylko pozornie powi¹zane.
@OneToMany:
Przy relacji jednokierunowej nale¿y stworzyæ dwie encje, a nastêpnie w jednej z nich tworzymy listê obiektów z drugiej encji i dodajemy adnotacjê @OneToMany, mo¿emy równie¿ dodaæ
adnotacjê @JoinColumn i stworzyæ kolumne o zadanej nazwie w drugim obiekcie bazodanowym.
Przy relacji dwukieunkowej zasada podobna do dwukierunkowej w @onetoone, nalezy pamiêtaæ o mapped by po stronie encji, w której jest @OneToMany (jeden).
W tym wypadku @Joincolumn dajemy w encji, której jest wiele (@ManyToOne)

!!!WA¯NE!!! - w momencie gdy tworzymy konstruktor sprametryzowany dla encji wa¿nym jest aby stworzyæ równie¿ konstrukotor domyœlny na potrzeby JPA. W innym wypadku zapis i odczyt z bazy nie zadzia³a.

@ManyToMany:
Relacja ta mo¿e byæ jedynie dwukierunkowa. Tworzymy j¹ dodaj¹c adnotacjê @ManyToMany w ka¿dej z encji przy polu drugiej encji.
W jednej z nich musimy dodaæ "mapped by"tak jak w powy¿szych przyk³adach.
JPA automatycznie utworzy w naszej bazie danych dodatkow¹ tabelê przedstawiaj¹c¹ relacjê obu encji.
Domyœlnie nazwa ta jest to nazwa jednej tabeli + "_" + nazwa drugiej tabeli.
Mozemy zmieniæ nazwê tabeli ³¹cz¹cej wykorzystjuj¹c adnotacjê @JoinTable w jednej z encji pod adnotacj¹ @ManyToMany.
Wygl¹da ona nastêpuj¹co
 @ManyToMany
    @JoinTable(
            name = "pracownicy_w_projektach",
            joinColumns = {@JoinColumn(name = "id_projektu")},
            inverseJoinColumns = {@JoinColumn(name = "id_pracownika")}
    )