Problem zapisu danych z modelu obiektowego do relacyjnej bazy danych.
w obkietkowoœci to s¹ obiekty po³¹czone ze sob¹ referencjami
w bazach relacyjnych - tabele.
Aby umo¿liwiæ po³¹czenie miêdzy obiektami a baz¹ danych wykorzystujemy interfejs JDBC - java database connectivity.
Jest to jednolite API korzustaj¹ce ze sterowników (biblioteki dla okreœlonych baz danych (odpowiedni jar)). 
Po JDPC powsta³o kilka innych rozwi¹zañ: JDPC Template - wzorzec, który umo¿liwa wykonywaæ zapytania w ³atwiejszy sposób. Unikamy problemów z ³apaniem wyj¹tków. Mamy do dyspozycji mappery,
 czyli klasy pozwal¹ce mapowaæ (data mappery). Jest wiele wiele wiêcej takich narzêdzi, nazwanych ogólnie ORM - Object Relational Mapping.

JPA - dokument, który opisuje w jaki sposób programista powinien pisaæ programy z wykorzystaniem JPA oraz jak powinna przebiegaæ implementacja (np. Hibernate jest implementacj¹ JPA).

Podstawowa konfiguracja nie wykorzustyj¹ca bootstrapa przebiega nastêpuj¹co:
	1. Mo¿na pobraæ ca³¹ paczkê jar hibernate-jpa-2.0-api
	2. Stworzenie projektu maven i dodanie dependencies: entitymenager, validator, search i core(?).
	3. Dodanie dependencies hibernate-jpa-2.0-api
Nastêpnie tworzymy w resoucres folder META-INF a w nim plik persistence.xml

Kolejn¹ bilbiotek¹ jest biblioteka ³¹cz¹ca siê z baz¹ czyli jdbc danej bazy danych.

Aby utworzyæ po³¹æzenie z baz¹ nale¿y wykorzystaæ EntityManagerFactor objekt, a nastêpnie stworzyæ na jego podstawie objekt EntityManager.

Korzystaj¹c z obiektu entityManager mo¿emy wykonywaæ transakcjê na bazie danych umo¿liwiaj¹ce operacje zapisu. A nastêpnie wykorzystuj¹c funkcjê presist zapisujemy wybrany obiekt w bazie danych.
 entityManager.getTransaction().begin();
 entityManager.persist(foo);
 entityManager.getTransaction().commit();

Pamiêtaæ o tym, aby w klasie na podstawie której chcemy utworzyæ tabele nale¿y dodaæ adnotacjê @Entity.

Przydatne adnotacje:
	1. @GeneratedValue(strategy = GenerationType.AUTO) - auto generowanie ID;
	2. @Column(name = "bla", nullable = false, length = 10) - d³ugoœæ i not null
	3. @Column(precision = 10, scale = 2) - dla BigDecimali iloœæ liczb dziesiêtnych i po przeicnku
	4. @Transient - dodana przy polu pomija go i nie dodaje jako kolumna w tabeli bazy danych.


Data i czas:
Wszystkie klasy java.sql.* s¹ wraperem na klasê java.util.Date
U¿ywaj¹c adnotacji @Temporal(TemporalType.DATE/TIME/TIMESTAMP) mo¿emy ustaliæ dany typ kolumny w bazie danuych.

Jedna klasa - dwie tabele:
Aby utworzyæ dwie tabele na podstawie jednej klasy dopisujemy adnotacjê @SecondTable(name = "nazwa_tabeli", pkJoinColumns = @PrimaryKeyJoinColumn(name = "nazwa_id_dla_primary_table"));
Nastêpnie do pól, które chcemy aby by³y w drugiej tabeli dodajemy adnotacjê @Table(name = "nazwa_tabeli_z_adnotacji_secondtable");

Klasa osadzona:
Klasa osadzona jest osobn¹ klas¹ z poziomu kodu, natomiast zawiera adnotacjê @Embeddable. Dziêki temu tworz¹c pole tej klasy w innej klasie oraz dodaj¹c adnotacjê @Embbeded
zostanie utworzona jedna tabela zmiast dwóch, ³¹cz¹ca pola z obu klas.

One-to-one:
Relacje jeden do jednego pomiêdzy dwoma klasami/tabelami tworzymy z u¿yciem adnotacji @OneToOne w jednej z klas przy polu, kórym jest obiuekt drugiej klasy.

Pobieranie i modyfikacja obiektu:
¯eby pobraæ obiekt wykorzystujemy metodê "find" z entity managera, która zwraca nam obiekt o typie podanym jako pierwszy parametr metody.
Mo¿emy nastêpnie zmodyfikowaæ taki obiekt wykorzystuj¹c settery i nie musimy go ponownie zapisywaæ do bazy metod¹ persist, w momencie commitowania tranzakcji obiekt ten
jest automatycznie aktualizowany.

Triggery:
Stworzony trigger w PostgreSQL, który po dodaniu pracownika do bazy danych automatycnzie wylicza i ustawia wartoœæ dla poola "tax".

Usuwanie obiektów z DB:
Wykorzystujemy metodê entity managera - remove(), któa przyjmuje referencje do usuwanego obiektu. Wczeœniej najlepiej znaleŸæ sobie odpowiedni obiekt metod¹ find, a nastêpnie go usun¹æ.
Pamiêtaæ o tym aby usuwanie obiektu przeprowadziæ w osobnej trasakcji!

JPQL:
Do wykonania zapytania na bazie danych w tym jêzyku nale¿y skorzystaæ z metody entity managera - query. Aczkolwiek ten sposób nie jest bezpieczny patrz¹c od strony programistycznej.
Przekazywanie parametrów zadanych w JPQL wygl¹da nastêpuj¹co, w query w miejscu w którym chcemy zadaæ jak¹œ wartoœæ poprzedzamy nazwê zmiennej dwukropkiem np. "where e.salary > :minSalary".
Nastêpnie parametr taki inicjalizujemy za pomoc¹ metody setParametr("minSalary", 3000.0);
Inn¹ metod¹ podstawiania zmienny jest indeksowanie, wygl¹da ona nasepuj¹co: "where e.salary > ?1", a nastêpnie w petodzie setParametr ustawiamy j¹w ten spobób setParametr(1, 2000.0);
Ostania metoda to przekazanie ca³ej listy zmiennych, które ma spe³niaæ zapytanie: "where e.lastName in :names" - znalezienie wszystkich pracowników ktrórych nazwiska znajduj¹ si w liœcie "names".
Tworzymy tak¹ listê, a nastêpnie przypisujemy j¹ w metodzie setParametr("names", names);